{"version":3,"sources":["simple-segment-aggregation.js"],"names":[],"mappings":"AAAA,AAAC,CAAA,UAAU,QAAQ,SAAS;AAC1B,SAAO,YAAY,YAAY,OAAO,WAAW,cAAc,OAAO,UAAU,QAAQ,QAAQ,iBAChG,OAAO,WAAW,cAAc,OAAO,MAAM,OAAO,CAAC,eAAe,WACpE,OAAO,2BAA2B,QAAQ,OAAO;GACjD,MAAM,UAAU,GAAG;AAAE;;AAErB,MAAI,2BAA2B;;;AAG7B,eAAS,mBAAC,OAAO,OAAO,SAAS;AAC/B,cAAQ,SAAS;AACjB,gBAAU,WAAW;AACrB,QAAE,SAAS,SAAS;AAClB,qBAAa;;;AAGf,UAAI,aAAa;;AAEjB,UAAI,CAAC,SAAS,CAAC,MAAM,QAAQ;AAC3B,eAAO;;;AAGT,UAAI;UACF;UACA,IAAI;UACJ;UACA;UACA;UACA;;AAEF,QAAE,KAAK,OAAO,UAAC,GAAG,OAAU;AAC1B,qBAAa,EAAE,MAAM,EAAE,QAAQ,QAAQ;AACvC,4BAAoB;;AAEpB,YAAI,OAAO;;AAET,uBAAa,WAAW,WAAW,QAAQ;AAC3C,sBAAY,EAAE,aAAa,YAAY;;AAEvC,sBAAY,UAAU,WAAW,WAAW;;;AAG5C,cAAI,cAAc,WAAW;AAC3B,uBAAW,GAAG;;;;eAIX;AACH;AACA,gBAAI,UAAU,QAAQ;AACpB,yBAAW,IAAI,GAAG,mBAAmB;AACrC,kCAAoB;;;;;;;;AAQ1B,YAAI,CAAC,WAAW,IAAI;AAClB,qBAAW,KAAK;AACd,oBAAQ,EAAE,MAAM,EAAE;AAClB,mBAAO,CAAC,EAAE;AACV,sBAAU;AACV,8BAAkB;AAClB,+BAAmB;;;;AAIvB,kBAAU;;;AAGZ,aAAO;;;;AAIX,MAAI,6BAA6B;;AAEjC,SAAO","file":"simple-segment-aggregation.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore')) :\n  typeof define === 'function' && define.amd ? define(['underscore'], factory) :\n  global.SimpleSegmentAggregation = factory(global._)\n}(this, function (_) { 'use strict';\n\n  var SimpleSegmentAggregation = {\n\n    // Segment an array of events by scale\n    aggregate(group, scale, options) {\n      scale = scale || 'weeks';\n      options = options || {};\n      _.defaults(options, {\n        idAttribute: 'id'\n      });\n\n      var aggregates = [];\n\n      if (!group || !group.length) {\n        return aggregates;\n      }\n\n      var prevIds,\n        currentIds,\n        i = 0,\n        intersect,\n        sameLength,\n        allEvents,\n        continuesBackward;\n\n      _.each(group, (g, index) => {\n        currentIds = _.pluck(g.events, options.idAttribute);\n        continuesBackward = false;\n\n        if (index) {\n          // Whether the contents have the same length\n          sameLength = currentIds.length === prevIds.length;\n          intersect = _.intersection(currentIds, prevIds);\n          // Whether the events in the current list are all contained within the last\n          allEvents = intersect.length === currentIds.length;\n\n          // This means that they occupy the same aggregate\n          if (sameLength && allEvents) {\n            aggregates[i].duration++;\n          }\n\n          // Otherwise, we need to make a new aggregate\n          else {\n            i++;\n            if (intersect.length) {\n              aggregates[i - 1].continuesForward = true;\n              continuesBackward = true;\n            }\n          }\n        }\n        \n        // The algorithm is pessimistic. Assume that the\n        // block does not extend forward. Subsequent\n        // iterations disprove, and modify, the assumption\n        if (!aggregates[i]) {\n          aggregates[i] = {\n            events: _.clone(g.events),\n            start: +g.timestamp,\n            duration: 1,\n            continuesForward: false,\n            continuesBackward: continuesBackward\n          };\n        }\n\n        prevIds = currentIds;\n      });\n\n      return aggregates;\n    }\n  };\n\n  var simple_segment_aggregation = SimpleSegmentAggregation;\n\n  return simple_segment_aggregation;\n\n}));\n"],"sourceRoot":"/source/"}