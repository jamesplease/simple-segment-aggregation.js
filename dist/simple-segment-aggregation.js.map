{"version":3,"sources":["simple-segment-aggregation.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;;AAEA;;EAEH,iBAAiB,CAAC,EAAE;AACnB;;AAIA,MAAI,wBAAwB,GAAG;;;AAG7B,aAAS,EAAE,UAAS,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE;AACzC,WAAK,GAAG,KAAK,IAAI,OAAO,CAAC;AACzB,aAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AACxB,OAAC,CAAC,QAAQ,CAAC,OAAO,EAAE;AAClB,mBAAW,EAAE,IAAI;OAClB,CAAC,CAAC;;AAEH,UAAI,UAAU,GAAG,EAAE,CAAC;;AAEpB,UAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;AAC3B,eAAO,UAAU,CAAC;OACnB;;AAED,UAAI,OAAO;UACT,UAAU;UACV,CAAC,GAAG,CAAC;UACL,SAAS;UACT,UAAU;UACV,SAAS;UACT,iBAAiB,CAAC;;AAEpB,OAAC,CAAC,IAAI,CAAC,KAAK,EAAE,UAAS,CAAC,EAAE,KAAK,EAAE;AAC/B,kBAAU,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,WAAW,CAAC,CAAC;AACpD,yBAAiB,GAAG,KAAK,CAAC;;AAE1B,YAAI,KAAK,EAAE;;AAET,oBAAU,GAAG,UAAU,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,CAAC;AAClD,mBAAS,GAAG,CAAC,CAAC,YAAY,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;;AAEhD,mBAAS,GAAG,SAAS,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,CAAC;;;AAGnD,cAAI,UAAU,IAAI,SAAS,EAAE;AAC3B,sBAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;WAC1B;;;eAGI;AACH,aAAC,EAAE,CAAC;AACJ,gBAAI,SAAS,CAAC,MAAM,EAAE;AACpB,wBAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,gBAAgB,GAAG,IAAI,CAAC;AAC1C,+BAAiB,GAAG,IAAI,CAAC;aAC1B;WACF;SACF;;;;;AAKD,YAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;AAClB,oBAAU,CAAC,CAAC,CAAC,GAAG;AACd,kBAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC;AACzB,iBAAK,EAAE,CAAC,CAAC,CAAC,SAAS;AACnB,oBAAQ,EAAE,CAAC;AACX,4BAAgB,EAAE,KAAK;AACvB,6BAAiB,EAAE,iBAAiB;WACrC,CAAC;SACH;;AAED,eAAO,GAAG,UAAU,CAAC;OACtB,CAAC,CAAC;;AAEH,aAAO,UAAU,CAAC;KACnB;GACF,CAAC;;;;;AAKF,SAAO,wBAAwB,CAAC;CACjC,CAAC,CAAC","file":"simple-segment-aggregation.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    module.exports = factory(_);\n  } else {\n    root.SimpleSegmentAggregation = factory(root._);\n  }\n})(this, function(_) {\n  'use strict';\n\n  import _ from 'underscore';\n  \n  var SimpleSegmentAggregation = {\n  \n    // Segment an array of events by scale\n    aggregate: function(group, scale, options) {\n      scale = scale || 'weeks';\n      options = options || {};\n      _.defaults(options, {\n        idAttribute: 'id'\n      });\n  \n      var aggregates = [];\n  \n      if (!group || !group.length) {\n        return aggregates;\n      }\n  \n      var prevIds,\n        currentIds,\n        i = 0,\n        intersect,\n        sameLength,\n        allEvents,\n        continuesBackward;\n  \n      _.each(group, function(g, index) {\n        currentIds = _.pluck(g.events, options.idAttribute);\n        continuesBackward = false;\n  \n        if (index) {\n          // Whether the contents have the same length\n          sameLength = currentIds.length === prevIds.length;\n          intersect = _.intersection(currentIds, prevIds);\n          // Whether the events in the current list are all contained within the last\n          allEvents = intersect.length === currentIds.length;\n  \n          // This means that they occupy the same aggregate\n          if (sameLength && allEvents) {\n            aggregates[i].duration++;\n          }\n  \n          // Otherwise, we need to make a new aggregate\n          else {\n            i++;\n            if (intersect.length) {\n              aggregates[i - 1].continuesForward = true;\n              continuesBackward = true;\n            }\n          }\n        }\n        \n        // The algorithm is pessimistic. Assume that the\n        // block does not extend forward. Subsequent\n        // iterations disprove, and modify, the assumption\n        if (!aggregates[i]) {\n          aggregates[i] = {\n            events: _.clone(g.events),\n            start: +g.timestamp,\n            duration: 1,\n            continuesForward: false,\n            continuesBackward: continuesBackward\n          };\n        }\n  \n        prevIds = currentIds;\n      });\n  \n      return aggregates;\n    }\n  };\n  \n  export default SimpleSegmentAggregation;\n  \n  \n  return SimpleSegmentAggregation;\n});\n"],"sourceRoot":"/source/"}